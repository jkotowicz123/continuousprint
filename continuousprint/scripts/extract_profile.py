import re
import sys
import os
from continuousprint.data import PRINTER_PROFILES


def _strip_nonalpha(s: str):
    assert type(s) is str
    return re.sub("[^0-9a-zA-Z]+", " ", s)


PROFILES = list(PRINTER_PROFILES.keys())
# Full candidates include profile name tokens + extra_tags (for gcode content matching)
CANDIDATES = [
    set(_strip_nonalpha(k).split()).union(
        set(PRINTER_PROFILES[k].get("extra_tags", []))
    )
    for k in PROFILES
]
# Extra tags only (for filename matching - more precise)
EXTRA_TAGS_ONLY = [
    set(PRINTER_PROFILES[k].get("extra_tags", []))
    for k in PROFILES
]


class KiriMotoProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; Generated by Kiri:Moto"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in hdr:
            if line.startswith("; Target:"):
                return re.match("; Target: (.*)", line)[1]
        return ""


class PrusaSlicerProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; generated by PrusaSlicer"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in ftr:
            if line.startswith("; printer_model = "):
                return re.match("; printer_model = (.*)", line)[1]
        return ""


class Simplify3DProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; G-Code generated by Simplify3D"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in hdr:
            m = re.match(";   profileName,(.*)", line)
            print(line, "->", m)
            if m is not None:
                return m[1]
        return ""


def token_string_match(profstr):
    # Remove non-alpha characters from profile string
    # Convert all into bag-of-words
    p = set(_strip_nonalpha(profstr).split())

    scores = [len(p.intersection(c)) for c in CANDIDATES]
    sys.stderr.write(f"Scoring '{profstr}':\n")
    desc = sorted(zip(PROFILES, scores), key=lambda x: x[1], reverse=True)
    for p, s in desc[:4]:
        if s == 0:
            continue
        sys.stderr.write(f"- {p}: {s}\n")
    sys.stderr.write("- ...\n")
    max_score = max(scores)
    if max_score < 1:
        return None
    max_index = scores.index(max_score)
    return PROFILES[max_index]


PROCESSORS = [
    (cls.__name__, cls.match, cls.get_profile)
    for cls in [KiriMotoProcessor, PrusaSlicerProcessor, Simplify3DProcessor]
]

gcode_move_re = re.compile("^G[012] .*")
gcode_multiline_re = re.compile("\nG[012] .*", re.M)


def get_header(path: str):
    hdr = []
    with open(path) as f:
        for line in f:
            if line.strip() == "":
                continue
            if gcode_move_re.match(line):
                return hdr
            hdr.append(line)
    return hdr


def get_footer(path: str):
    # Read backwards from end of file to find comments after last gcode move
    # PrusaSlicer can have several KB of config at the end
    ftr = []
    JUMP = 4096  # Increased to handle large slicer config dumps
    with open(path, "rb") as f:
        try:
            f.seek(-JUMP, os.SEEK_END)
        except OSError:
            f.seek(0)  # File smaller than JUMP, start from beginning
        
        # Find where gcode moves end by searching backwards
        pos = f.tell()
        content = f.read().decode("utf8", errors="ignore")
        
        # Find last gcode move in this chunk
        last_gcode = -1
        for m in gcode_multiline_re.finditer(content):
            last_gcode = m.end()
        
        if last_gcode == -1:
            # No gcode found in last chunk, keep searching backwards
            # For simplicity, just read all comments from current position
            pass
        
        # Read all comment lines after the last gcode move
        f.seek(pos)
        for line in f:
            ln = line.decode("utf8", errors="ignore")
            if ln.startswith(";"):
                ftr.append(ln)
    return ftr


def get_profile_from_filename(path: str):
    # Extract profile from filename using extra_tags only (more precise)
    # e.g. "Shape-Box_MK4_2h38m.gcode" -> matches "MK4" tag -> "Prusa MK4"
    filename = os.path.basename(path)
    name_without_ext = os.path.splitext(filename)[0]
    sys.stderr.write(f"Checking filename: {name_without_ext}\n")
    
    # Use extra_tags only for filename matching to avoid false positives
    p = set(_strip_nonalpha(name_without_ext).split())
    scores = [len(p.intersection(c)) for c in EXTRA_TAGS_ONLY]
    
    sys.stderr.write(f"Scoring filename against extra_tags:\n")
    desc = sorted(zip(PROFILES, scores), key=lambda x: x[1], reverse=True)
    for prof, s in desc[:4]:
        if s == 0:
            continue
        sys.stderr.write(f"- {prof}: {s}\n")
    sys.stderr.write("- ...\n")
    
    max_score = max(scores) if scores else 0
    if max_score < 1:
        return None
    max_index = scores.index(max_score)
    return PROFILES[max_index]


def get_profile_from_gcode(hdr: list, ftr: list):
    for name, match, getprof in PROCESSORS:
        if match(hdr, ftr):
            sys.stderr.write(f"File matched with {name}\n")
            profstr = getprof(hdr, ftr)
            return token_string_match(profstr)
    return None


if __name__ == "__main__":
    sys.stderr.write("=== Continuous Print Profile Inference ===\n")
    path = sys.argv[1]
    
    # Try filename first (most reliable for PrusaSlicer default naming)
    prof = get_profile_from_filename(path)
    
    # Fall back to gcode content parsing
    if prof is None:
        hdr = get_header(path)
        ftr = get_footer(path)
        prof = get_profile_from_gcode(hdr, ftr)
    
    if prof is not None:
        sys.stdout.write(prof)
    sys.stdout.flush()
    sys.stderr.write("\n=== End Inference ===\n")
